
{% load staticfiles %}
{% load static %}
{% get_media_prefix as media %}

<!-- check git master branch commit "change center qr something" for centering camera feed -->

<!-- Script to load 3D object  -->
<head>
  <!-- temp css declaration
    figure out how to import the django way-->
  <link rel="stylesheet" href="../../static/styles/view_ar.css">


  <title> Display Model </title>
  <script>

    // var object_to_load_obj_path = "{% static "renders/" %}{{renderObj.object_path}}";


    var object_to_load_obj_path ="";
    var object_to_load_colormap_path = "";
    var object_to_load_specmap_path = "";
    var object_to_load_normalmap_path = "";

    object_to_load_obj_path = "{{ media }}renders/{{ renderObj.object_path }}";
    object_to_load_colormap_path = "{{ media }}renders/{{ renderObj.colormap_path }}";
    object_to_load_specmap_path = "{{ media }}renders/{{ renderObj.specmap_path }}";
    object_to_load_normalmap_path = "{{ media }}renders/{{ renderObj.normalmap_path }}";
  </script>



  <!--<script src="{% static "three.js/build/ar.js" %}"></script>-->
  <script src="https://cdn.rawgit.com/mrdoob/three.js/r84/build/three.min.js" ></script>
  <script src="{% static 'three.js/build/ar.js'  %}"> </script>
  <script>THREEx.ArToolkitContext.baseURL = '{% static "three.js" %}'</script>

  <script src="{% static "scripts/draco_decoder.js" %}"></script>
  <script src="{% static "scripts/DRACOLoader.js" %}" ></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

  <script src="{% static "qrcode_lib/" %}html5-qrcode.min.js"></script>
  <script src="{% static "qrcode_lib/" %}jsqrcode-combined.min.js"></script>
</head>



<!-- BODY BEGINS HERE -->
<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>

  <div style='position: absolute; top: 10px; width:100%; text-align: center; z-index: 1;'>
    <!-- <a target="_blank">AR.js - three.js camera transform </a> -->


    <button type = "button" id = "startQR" onclick = "startqrscan()">Start Qr Scan</button>
    <button type = "button" id = "stopQR" onclick = "stopQRScan()" style="display: none;">Cancel Scan</button>
  </div>

  <!-- div where we'll put the feed -->
  <!-- this div is in charge of qr reading camera feed -->

  <!-- hide initially then show onclick -->
  <!-- change display (look at line 213) -->


  <!-- how does this tag create a qr feed? where is main feed initialied? -->
  <div id = "camera-feed" style = " width:300px;height:250px"></div>
  <script>

  </script>

  <!-- qr code below -->
  <script id = "qrReader">

    var qrFeed = document.getElementById("camera-feed");
    qrFeed.style.display = "none";
    var mainFeed;

    //start button var
    var startButton = document.getElementById("startQR");
    var stopButton = document.getElementById("stopQR");

    // load refers to initial loading of webpage
    window.addEventListener("load", function load(event){
      $('#camera-feed').html5_qrcode(function(data){
        console.log("data READ");
        stopButton.style.display = 'none';

        //data is the qr #
        console.log(data);
        loadDoc(data);

        startButton.style.display = 'block';
        startButton.style.margin = 'auto';
        qrFeed.style.display = 'none';


        //line shows main feed
        //mainFeed.style.display = 'block';
        document.getElementsByTagName('video')[1].style.display = 'block';

        //console.log(document.getElementById("link").style.href);
        document.getElementById("link").href = "http://"+data;
        document.getElementById("link").style.display = "";

      },
      /// do we actually need these functions? ///
      function(error){
        //show read errors
        //console.log("QR Read Error")
      },
      function(videoError){
        //the video stream could be opened
      });

      //////////////////////////////////////////
    },false);

    //var mainFeed = document.getElementsByTagName('video')[1];

    function startqrscan () {

      stopButton.style.display = "";
      startButton.style.display = "none";

      qrFeed.style.display = 'block';
      document.getElementsByTagName('video')[1].style.display = 'none';
      //mainFeed.style.display = 'none';
    }

    //called when cancel scan is clicked
    function stopQRScan(){

      //show main feed
      //mainFeed.style.display = 'block';
      document.getElementsByTagName('video')[1].style.display = 'block';
      //show the start button
      startButton.style.display = 'block';
      startButton.style.margin = 'auto';
      //hide the cancel button
      stopButton.style.display = "none";
      //hide qrFeed
      qrFeed.style.display = "none";

    }
  </script>

  <script>

    ///////////////////////////////////////////////////////////////////////////
    //		Init
    ///////////////////////////////////////////////////////////////////////////
    // init renderer
    var renderer	= new THREE.WebGLRenderer({
      antialias: true,
      alpha: true
    });
    //what does this block do?
    renderer.setClearColor(new THREE.Color('lightgrey'), 0)
    renderer.setSize( 640, 480 );
    renderer.domElement.style.position = 'absolute'
    renderer.domElement.style.top = '0px'
    renderer.domElement.style.left = '0px'
    document.body.appendChild( renderer.domElement );
    // array of functions for the rendering loop
    var onRenderFcts= [];
    // init scene and camera
    var scene	= new THREE.Scene();

    //////////////////////////////////////////////////////////////////////////////////
    //		Initialize a basic camera
    //////////////////////////////////////////////////////////////////////////////////
    // Create a camera
    var camera = new THREE.Camera();

    //what does this line do?
    // the two camera feeds still show up after I comment this out?
    // three js camera
    scene.add(camera);


    ////////////////////////////////////////////////////////////////////////////////
    //          handle arToolkitSource
    ////////////////////////////////////////////////////////////////////////////////
    var arToolkitSource = new THREEx.ArToolkitSource({
      // to read from the webcam
      sourceType : 'webcam',
      // CAN THIS BLOCK BE DELETED?
      // // to read from an image
      // sourceType : 'image',
      // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/images/img.jpg',
      // to read from a video
      // sourceType : 'video',
      // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',
    })
    arToolkitSource.init(function onReady(){
      onResize()
    })

    // handle resize
    window.addEventListener('resize', function(){
      onResize()
    })
    function onResize(){
      arToolkitSource.onResize()
      arToolkitSource.copySizeTo(renderer.domElement)
      if( arToolkitContext.arController !== null ){
    	  arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
      }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //          initialize arToolkitContext
    ////////////////////////////////////////////////////////////////////////////////

    // create atToolkitContext
    var arToolkitContext = new THREEx.ArToolkitContext({
      cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../../camera_para.dat',
      detectionMode: 'mono',
    })
    // initialize it
    arToolkitContext.init(function onCompleted(){
      // copy projection matrix to camera
      camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
    })
  </script>

  <script>

    var ajaxRequest;

    var data_parse
    function loadDoc(marker_id) {
      // console.log("hello")
      $.get('/tours/get_render/' + marker_id , function(data) {
        data_parse = JSON.parse(data);
        // var sample = 'Remove stuff before this word. Hello!';
        // var substr = sample.substring(sample.indexOf('word'));
        var path = data_parse[0].fields.colormap_path;;
        var new_path = path.substring(path.indexOf('/media'));;
        data_parse[0].fields.colormap_path = new_path;;

        path = data_parse[0].fields.normalmap_path;;
        new_path = path.substring(path.indexOf('/media'));;
        data_parse[0].fields.normalmap_path = new_path;;

        path = data_parse[0].fields.object_path;;
        new_path = path.substring(path.indexOf('/media'));;
        data_parse[0].fields.object_path = new_path;;

        path = data_parse[0].fields.specmap_path;;
        new_path = path.substring(path.indexOf('/media'));;
        data_parse[0].fields.specmap_path = new_path;;

        console.log(data_parse);
        loadDracoModel_json(data_parse);

      });
    }
    // document.getElementsByTagName('video')[0].style.display = 'none';


    // startqrscan is activated when button clicked

  </script>


  <script>

    //  when marker is found, arToolkitSource.ready === true

    onRenderFcts.push(function(){
      if( arToolkitSource.ready === false )	return
      arToolkitContext.update( arToolkitSource.domElement )

      // update scene.visible if the marker is seen
      scene.visible = camera.visible
    })


    ////////////////////////////////////////////////////////////////////////////////
    //          Create a ArMarkerControls
    ////////////////////////////////////////////////////////////////////////////////

    //below code responsible for recognizing pattern
    //look into THREEx.ArMarkerControls on ArToolKit
    //arToolkitContext: "finds marker position in img source"
    //ArMarkerControls: controls position of marker, positions content on top of marker
    // init controls for camera
    var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
      type : 'pattern',
      patternUrl : 'https://raw.githubusercontent.com/jeromeetienne/AR.js/master/data/data/patt.hiro',
      // patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
      // as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
      changeMatrixMode: 'cameraTransformMatrix'
    })
    // as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
    scene.visible = false

    //////////////////////////////////////////////////////////////////////////////////
    //		add an object in the scene
    //////////////////////////////////////////////////////////////////////////////////
    // add a torus knot
    var geometry	= new THREE.CubeGeometry(1,1,1);
    var material	= new THREE.MeshNormalMaterial({
      transparent : true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    var mesh	= new THREE.Mesh( geometry, material );
    mesh.visible = false;
    // mesh.position.y	= geometry.parameters.height/2
    scene.add( mesh );

    // var geometry	= new THREE.TorusKnotGeometry(0.3,0.1,64,16);
    // var material	= new THREE.MeshNormalMaterial();
    // var mesh	= new THREE.Mesh( geometry, material );
    // mesh.position.y	= 0.5
    // scene.add( mesh );
    console.log("b4 draco load");
    var textureLoader = new THREE.TextureLoader();
    loadDracoModel();
    console.log("after load");
    onRenderFcts.push(function(delta){
      mesh.rotation.x += Math.PI*delta
    });
    //////////////////////////////////////////////////////////////////////////////////
    //		render the whole thing on the page
    //////////////////////////////////////////////////////////////////////////////////
    // render the scene
    onRenderFcts.push(function(){
      renderer.render( scene, camera );
    })
    // run the rendering loop
    var lastTimeMsec= null
    requestAnimationFrame(function animate(nowMsec){
      // keep looping
      requestAnimationFrame( animate );
      // measure time
      lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
      var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
      lastTimeMsec	= nowMsec
      // call each update function
      onRenderFcts.forEach(function(onRenderFct){
      	onRenderFct(deltaMsec/1000, nowMsec/1000)
      })
    })

    //TODO: have function take args: object


    function loadDracoModel() {
      var loader = new THREE.DRACOLoader();

      //TODO: This takes out the extension and replaces it for a .drc. This is because the post_save signal function updates after a few saved_annotations
      //Should solve this issue in backend else the input obj will always be needed and take storage space on server
      console.log(object_to_load_obj_path);
      object_to_load_obj_path = object_to_load_obj_path.substr(0, object_to_load_obj_path.lastIndexOf(".")) + ".drc";
      console.log(object_to_load_obj_path);
      // TEST speed .obj vs .obj
      // object_to_load_path = "../../static\models\Homo_Erectus\he_og\Taung_Child_Top\Taung_Child_Top.obj"
      loader.load( object_to_load_obj_path, function ( geometry ) {
        geometry.computeVertexNormals();
        var material = new THREE.MeshPhongMaterial( {
          specular: 0x111111,
          //map: textureLoader.load( '../../static/models/Homo_Erectus/he_og/Taung_Child_Top/Taung_Child_Top01.jpg' ),
          //specularMap: textureLoader.load('../../static/models/leeperrysmith/Map-SPEC.jpg' ),
          //normalMap: textureLoader.load( '../../static/models/Homo_Erectus/he_og/Taung_Child_Top/NormalMap_1.jpg'),
          map: textureLoader.load( object_to_load_colormap_path ),
          normalMap: textureLoader.load( object_to_load_normalmap_path),
          normalScale: new THREE.Vector2( 0.75, 0.75 ),
          shininess: 25
        } );

        //var bufferGeometry = new THREE.BufferGeometry().fromGeometry( geometry );
        console.log("loadDracomodel - geometry = ",geometry);

        var bufferGeometry = geometry;
        bufferGeometry.computeVertexNormals();
        bufferGeometry.computeBoundingBox();
        const sizeX = bufferGeometry.boundingBox.max.x - bufferGeometry.boundingBox.min.x;
        const sizeY = bufferGeometry.boundingBox.max.y - bufferGeometry.boundingBox.min.y;
        const sizeZ = bufferGeometry.boundingBox.max.z - bufferGeometry.boundingBox.min.z;
        const diagonalSize = Math.sqrt(sizeX * sizeX + sizeY * sizeY + sizeZ * sizeZ);
        const scale = 1.0 / diagonalSize;
        const midX = (bufferGeometry.boundingBox.min.x + bufferGeometry.boundingBox.max.x) / 2;
        const midY = (bufferGeometry.boundingBox.min.y + bufferGeometry.boundingBox.max.y) / 2;
        const midZ = (bufferGeometry.boundingBox.min.z + bufferGeometry.boundingBox.max.z) / 2;

        // //geometry.scale(scale,scale,scale);
        // geometry.scale(0.10,0.10,0.10);
        // var loaded_mesh = new THREE.Mesh( geometry, material );
        // scene.add( loaded_mesh );
      });
    }


    function loadDracoModel_json(json_data) {
      var loader = new THREE.DRACOLoader();

      //TODO: This takes out the extension and replaces it for a .drc. This is because the post_save signal function updates after a few saved_annotations
      //Should solve this issue in backend else the input obj will always be needed and take storage space on server
      var object_path = json_data[0].fields.object_path;
      object_path = object_path.substr(0, object_path.lastIndexOf(".")) + ".drc";

      // TEST speed .obj vs .obj
      // object_to_load_path = "../../static\models\Homo_Erectus\he_og\Taung_Child_Top\Taung_Child_Top.obj"
      loader.load( object_path, function ( geometry ) {
        geometry.computeVertexNormals();
        var material = new THREE.MeshPhongMaterial( {
          specular: 0x111111,
          //map: textureLoader.load( '../../static/models/Homo_Erectus/he_og/Taung_Child_Top/Taung_Child_Top01.jpg' ),
          //specularMap: textureLoader.load('../../static/models/leeperrysmith/Map-SPEC.jpg' ),
          //normalMap: textureLoader.load( '../../static/models/Homo_Erectus/he_og/Taung_Child_Top/NormalMap_1.jpg'),
          map: textureLoader.load( json_data[0].fields.colormap_path ),
          normalMap: textureLoader.load( json_data[0].fields.normalmap_path),
          normalScale: new THREE.Vector2( 0.75, 0.75 ),
          shininess: 25
        } );

        //var bufferGeometry = new THREE.BufferGeometry().fromGeometry( geometry );
        console.log("loadDracomodel - geometry = ",geometry);

        var bufferGeometry = geometry;
        bufferGeometry.computeVertexNormals();
        bufferGeometry.computeBoundingBox();
        const sizeX = bufferGeometry.boundingBox.max.x - bufferGeometry.boundingBox.min.x;
        const sizeY = bufferGeometry.boundingBox.max.y - bufferGeometry.boundingBox.min.y;
        const sizeZ = bufferGeometry.boundingBox.max.z - bufferGeometry.boundingBox.min.z;
        const diagonalSize = Math.sqrt(sizeX * sizeX + sizeY * sizeY + sizeZ * sizeZ);
        const scale = 1.0 / diagonalSize;
        const midX = (bufferGeometry.boundingBox.min.x + bufferGeometry.boundingBox.max.x) / 2;
        const midY = (bufferGeometry.boundingBox.min.y + bufferGeometry.boundingBox.max.y) / 2;
        const midZ = (bufferGeometry.boundingBox.min.z + bufferGeometry.boundingBox.max.z) / 2;

        //geometry.scale(scale,scale,scale);
        geometry.scale(10,10,10);
        var loaded_mesh = new THREE.Mesh( geometry, material );
        scene.remove(scene.children[scene.children.length-1]);
        scene.add( loaded_mesh );
      } );
    }

  </script>
    <!-- AJAX Setup -->
    <script>
    function getCookie(name) {
      var cookieValue = null;
      if (document.cookie && document.cookie != '') {
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
          var cookie = jQuery.trim(cookies[i]);
          // Does this cookie string begin with the name we want?
          if (cookie.substring(0, name.length + 1) == (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }
    function csrfSafeMethod(method) {
      // these HTTP methods do not require CSRF protection
      return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
    }
    function sameOrigin(url) {
     // test that a given url is a same-origin URL
     // url could be relative or scheme relative or absolute
     var host = document.location.host; // host + port
     var protocol = document.location.protocol;
     var sr_origin = '//' + host;
     var origin = protocol + sr_origin;
     // Allow absolute or scheme relative URLs to same origin
     return (url == origin || url.slice(0, origin.length + 1) == origin + '/') ||
     (url == sr_origin || url.slice(0, sr_origin.length + 1) == sr_origin + '/') ||
     // or any other URL that isn't scheme relative or absolute i.e relative.
     !(/^(\/\/|http:|https:).*/.test(url));
    }
    var csrftoken = getCookie('csrftoken')
    $.ajaxSetup({
      beforeSend: function(xhr, settings) {
        if (!csrfSafeMethod(settings.type) && sameOrigin(settings.url)) {
          // Send the token to same-origin, relative URLs only.
          // Send the token only if the method warrants CSRF protection
          // Using the CSRFToken value acquired earlier
          xhr.setRequestHeader("X-CSRFToken", csrftoken);
        }
     }
    });



  </script>

</body>
